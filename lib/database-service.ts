/**
 * Database service for Firestore operations
 * Handles all database interactions for hunts and user data
 */
import { 
  getFirestore, 
  collection, 
  addDoc, 
  getDocs, 
  query, 
  where, 
  orderBy,
  doc,
  getDoc,
  updateDoc,
  deleteDoc,
  Timestamp,
  serverTimestamp
} from 'firebase/firestore';
import app from './firebase-config';

// Initialize Firestore
const db = getFirestore(app);
console.log('üî• [Database Service] Firestore initialized:', db);

/**
 * Test Firestore connection
 * @returns {Promise<boolean>} - True if connection works
 */
export const testFirestoreConnection = async (): Promise<boolean> => {
  try {
    console.log('üß™ [Database Service] Testing Firestore connection...');
    const testCollection = collection(db, 'test');
    console.log('‚úÖ [Database Service] Firestore connection test successful');
    return true;
  } catch (error: any) {
    console.error('üí• [Database Service] Firestore connection test failed:', error);
    return false;
  }
};

/**
 * Get all hunts (for debugging purposes)
 * @returns {Promise<Hunt[]>} - Array of all hunts
 */
export const getAllHunts = async (): Promise<Hunt[]> => {
  console.log('üîç [Database Service] Getting ALL hunts (for debugging)...');
  
  try {
    const querySnapshot = await getDocs(collection(db, 'hunts'));
    console.log('üìä [Database Service] Total documents in hunts collection:', querySnapshot.size);
    
    const hunts: Hunt[] = [];
    querySnapshot.forEach((doc) => {
      const huntData = {
        id: doc.id,
        ...doc.data()
      } as Hunt;
      console.log('üìÑ [Database Service] Found hunt:', huntData);
      hunts.push(huntData);
    });

    return hunts;
  } catch (error: any) {
    console.error('üí• [Database Service] Error getting all hunts:', error);
    throw error;
  }
};

/**
 * Hunt interface for type safety
 */
export interface Hunt {
  id?: string;
  name: string;
  userId: string;
  createdAt: any; // Can be Date or Firestore Timestamp
  isVisible: boolean; // Flag indicating if hunt should be publicly visible and discoverable
}

/**
 * Location interface for type safety
 */
export interface Location {
  locationId?: string; // Unique identifier generated by the database (Firestore Document ID)
  huntId: string; // Foreign key linking to the parent hunt in the Hunts collection
  locationName: string; // The descriptive name of the location
  explanation: string; // A detailed explanation related to the location
  latitude: number; // The geographical latitude coordinate (required for completion/visibility)
  longitude: number; // The geographical longitude coordinate (required for completion/visibility)
}

/**
 * Condition interface for type safety
 */
export interface Condition {
  conditionId?: string; // Unique identifier generated by the database
  locationId: string; // Foreign key linking to the Location this condition applies to
  type: 'REQUIRED_LOCATION' | 'TIME_WINDOW'; // Enum: 'REQUIRED_LOCATION' or 'TIME_WINDOW'
  requiredLocationId?: string; // The locationId that must be completed first. (Used for AND logic if multiple conditions are present)
  startTime?: string; // Time string (e.g., "10:00"). (Used for OR logic if multiple time conditions are present)
  endTime?: string; // Time string (e.g., "14:30"). (Used for OR logic if multiple time conditions are present)
}

/**
 * Create a new hunt for the current user
 * @param {string} huntName - Name of the hunt
 * @param {string} userId - ID of the user creating the hunt
 * @returns {Promise<string>} - ID of the created hunt
 */
export const createHunt = async (huntName: string, userId: string): Promise<string> => {
  try {
    const huntData = {
      name: huntName,
      userId: userId,
      createdAt: serverTimestamp(),
      isVisible: false // Default to false - hunt is private by default
    };
    
    const docRef = await addDoc(collection(db, 'hunts'), huntData);
    console.log('‚úÖ Hunt created successfully with ID:', docRef.id);
    return docRef.id;
  } catch (error: any) {
    console.error('üí• Error creating hunt:', error);
    throw error;
  }
};

/**
 * Get all hunts for a specific user
 * @param {string} userId - ID of the user
 * @returns {Promise<Hunt[]>} - Array of user's hunts
 */
export const getUserHunts = async (userId: string): Promise<Hunt[]> => {
  console.log('üîç Getting hunts for user:', userId);
  
  try {
    // Try query with orderBy first
    let q = query(
      collection(db, 'hunts'),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc')
    );

    let querySnapshot;
    
    try {
      console.log('üìä Trying query with orderBy...');
      querySnapshot = await getDocs(q);
      console.log('‚úÖ Query with orderBy successful. Documents found:', querySnapshot.size);
    } catch (orderByError: any) {
      console.warn('‚ö†Ô∏è OrderBy query failed, trying without orderBy:', orderByError.message);
      
      // Fallback: query without orderBy if index doesn't exist
      q = query(
        collection(db, 'hunts'),
        where('userId', '==', userId)
      );
      
      querySnapshot = await getDocs(q);
      console.log('‚úÖ Query without orderBy successful. Documents found:', querySnapshot.size);
    }

    const hunts: Hunt[] = [];

    querySnapshot.forEach((doc) => {
      const huntData = doc.data();
      const hunt: Hunt = {
        id: doc.id,
        name: huntData.name,
        userId: huntData.userId,
        createdAt: huntData.createdAt,
        isVisible: huntData.isVisible || false // Default to false for existing documents without this field
      };
      console.log('üìÑ Found hunt:', hunt);
      hunts.push(hunt);
    });

    // Sort in JavaScript if we couldn't use orderBy
    if (hunts.length > 0 && !hunts[0].createdAt) {
      console.log('üîÑ Sorting hunts manually...');
      hunts.sort((a, b) => {
        const aDate = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(a.createdAt);
        const bDate = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(b.createdAt);
        return bDate.getTime() - aDate.getTime();
      });
    }

    console.log('‚úÖ Returning', hunts.length, 'hunts');
    return hunts;
  } catch (error: any) {
    console.error('üí• Error getting user hunts:', error);
    console.error('üí• Error details:', error.code, error.message);
    throw error;
  }
};

/**
 * Check if a hunt with the same name exists for the user
 * @param {string} huntName - Name of the hunt to check
 * @param {string} userId - ID of the user
 * @returns {Promise<boolean>} - True if hunt exists, false otherwise
 */
export const huntExistsForUser = async (huntName: string, userId: string): Promise<boolean> => {
  try {
    const q = query(
      collection(db, 'hunts'),
      where('userId', '==', userId),
      where('name', '==', huntName)
    );

    const querySnapshot = await getDocs(q);
    return !querySnapshot.empty;
  } catch (error) {
    console.error('Error checking if hunt exists:', error);
    throw error;
  }
};

/**
 * Get a specific hunt by ID
 * @param {string} huntId - ID of the hunt
 * @returns {Promise<Hunt | null>} - Hunt data or null if not found
 */
export const getHuntById = async (huntId: string): Promise<Hunt | null> => {
  try {
    const docRef = doc(db, 'hunts', huntId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      const huntData = docSnap.data();
      return {
        id: docSnap.id,
        name: huntData.name,
        userId: huntData.userId,
        createdAt: huntData.createdAt,
        isVisible: huntData.isVisible || false // Default to false for existing documents
      } as Hunt;
    } else {
      return null;
    }
  } catch (error) {
    console.error('Error getting hunt:', error);
    throw error;
  }
};

/**
 * Update a hunt's name
 * @param {string} huntId - ID of the hunt to update
 * @param {string} newName - New name for the hunt
 * @param {string} userId - ID of the user (for validation)
 * @returns {Promise<void>}
 */
export const updateHuntName = async (huntId: string, newName: string, userId: string): Promise<void> => {
  try {
    // First verify the hunt belongs to the user
    const hunt = await getHuntById(huntId);
    if (!hunt) {
      throw new Error('Hunt not found');
    }
    
    if (hunt.userId !== userId) {
      throw new Error('Unauthorized: Hunt does not belong to this user');
    }

    // Update the hunt name
    const docRef = doc(db, 'hunts', huntId);
    await updateDoc(docRef, {
      name: newName
    });
    
    console.log('‚úÖ Hunt name updated successfully');
  } catch (error: any) {
    console.error('üí• Error updating hunt name:', error);
    throw error;
  }
};

/**
 * Update hunt visibility (public/private)
 * @param {string} huntId - ID of the hunt to update
 * @param {boolean} isVisible - Whether hunt should be publicly visible
 * @param {string} userId - ID of the user (for validation)
 * @returns {Promise<void>}
 */
export const updateHuntVisibility = async (huntId: string, isVisible: boolean, userId: string): Promise<void> => {
  try {
    // First verify the hunt belongs to the user
    const hunt = await getHuntById(huntId);
    if (!hunt) {
      throw new Error('Hunt not found');
    }
    
    if (hunt.userId !== userId) {
      throw new Error('Unauthorized: Hunt does not belong to this user');
    }

    // Update the hunt visibility
    const docRef = doc(db, 'hunts', huntId);
    await updateDoc(docRef, {
      isVisible: isVisible
    });
    
    console.log(`‚úÖ Hunt visibility updated to ${isVisible ? 'public' : 'private'}`);
  } catch (error: any) {
    console.error('üí• Error updating hunt visibility:', error);
    throw error;
  }
};

/**
 * Get all publicly visible hunts (for discovery)
 * @returns {Promise<Hunt[]>} - Array of public hunts
 */
export const getPublicHunts = async (): Promise<Hunt[]> => {
  try {
    console.log('üîç [Database Service] Getting public hunts...');
    
    const q = query(
      collection(db, 'hunts'),
      where('isVisible', '==', true),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);
    const hunts: Hunt[] = [];

    querySnapshot.forEach((doc) => {
      const huntData = doc.data();
      hunts.push({
        id: doc.id,
        name: huntData.name,
        userId: huntData.userId,
        createdAt: huntData.createdAt,
        isVisible: huntData.isVisible || false // Fallback for existing documents
      });
    });

    console.log(`‚úÖ [Database Service] Found ${hunts.length} public hunts`);
    return hunts;
  } catch (error: any) {
    console.error('üí• [Database Service] Error getting public hunts:', error);
    throw error;
  }
};

/**
 * Migration function to add isVisible field to existing hunt documents
 * This should be run once to update all existing hunts
 * @returns {Promise<number>} - Number of documents updated
 */
export const migrateHuntsAddVisibilityField = async (): Promise<number> => {
  try {
    console.log('üîÑ [Migration] Starting migration to add isVisible field to existing hunts...');
    
    // Get all hunts that don't have isVisible field
    const querySnapshot = await getDocs(collection(db, 'hunts'));
    let updatedCount = 0;
    
    const updatePromises: Promise<void>[] = [];
    
    querySnapshot.forEach((docSnapshot) => {
      const huntData = docSnapshot.data();
      
      // Check if isVisible field is missing
      if (huntData.isVisible === undefined) {
        const updatePromise = updateDoc(doc(db, 'hunts', docSnapshot.id), {
          isVisible: false // Default to false (private)
        }).then(() => {
          console.log(`‚úÖ Updated hunt ${docSnapshot.id} with isVisible: false`);
          updatedCount++;
        });
        
        updatePromises.push(updatePromise);
      }
    });
    
    // Wait for all updates to complete
    await Promise.all(updatePromises);
    
    console.log(`‚úÖ [Migration] Migration completed. Updated ${updatedCount} hunt documents.`);
    return updatedCount;
  } catch (error: any) {
    console.error('üí• [Migration] Error during migration:', error);
    throw error;
  }
};

// ========================================
// LOCATIONS COLLECTION FUNCTIONS
// ========================================

/**
 * Create a new location for a hunt
 * @param {Omit<Location, 'locationId'>} locationData - Location data without ID
 * @returns {Promise<string>} - ID of the created location
 */
export const createLocation = async (locationData: Omit<Location, 'locationId'>): Promise<string> => {
  try {
    console.log('üìç [Database Service] Creating new location for hunt:', locationData.huntId);
    
    const docRef = await addDoc(collection(db, 'locations'), {
      huntId: locationData.huntId,
      locationName: locationData.locationName,
      explanation: locationData.explanation,
      latitude: locationData.latitude,
      longitude: locationData.longitude,
      createdAt: serverTimestamp()
    });
    
    console.log('‚úÖ Location created successfully with ID:', docRef.id);
    return docRef.id;
  } catch (error: any) {
    console.error('üí• Error creating location:', error);
    throw error;
  }
};

/**
 * Get all locations for a specific hunt
 * @param {string} huntId - ID of the hunt
 * @returns {Promise<Location[]>} - Array of locations for the hunt
 */
export const getHuntLocations = async (huntId: string): Promise<Location[]> => {
  try {
    console.log('üîç [Database Service] Getting locations for hunt:', huntId);
    
    const q = query(
      collection(db, 'locations'),
      where('huntId', '==', huntId)
    );

    const querySnapshot = await getDocs(q);
    const locations: Location[] = [];

    querySnapshot.forEach((doc) => {
      const locationData = doc.data();
      locations.push({
        locationId: doc.id,
        huntId: locationData.huntId,
        locationName: locationData.locationName,
        explanation: locationData.explanation,
        latitude: locationData.latitude,
        longitude: locationData.longitude
      });
    });

    console.log(`‚úÖ [Database Service] Found ${locations.length} locations for hunt`);
    return locations;
  } catch (error: any) {
    console.error('üí• [Database Service] Error getting hunt locations:', error);
    throw error;
  }
};

/**
 * Get a specific location by ID
 * @param {string} locationId - ID of the location
 * @returns {Promise<Location | null>} - Location object or null if not found
 */
export const getLocationById = async (locationId: string): Promise<Location | null> => {
  try {
    const docRef = doc(db, 'locations', locationId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      const locationData = docSnap.data();
      return {
        locationId: docSnap.id,
        huntId: locationData.huntId,
        locationName: locationData.locationName,
        explanation: locationData.explanation,
        latitude: locationData.latitude,
        longitude: locationData.longitude
      } as Location;
    } else {
      return null;
    }
  } catch (error) {
    console.error('Error getting location:', error);
    throw error;
  }
};

/**
 * Update a location's information
 * @param {string} locationId - ID of the location to update
 * @param {Partial<Omit<Location, 'locationId' | 'huntId'>>} updates - Fields to update
 * @returns {Promise<void>}
 */
export const updateLocation = async (
  locationId: string, 
  updates: Partial<Omit<Location, 'locationId' | 'huntId'>>
): Promise<void> => {
  try {
    const docRef = doc(db, 'locations', locationId);
    await updateDoc(docRef, {
      ...updates,
      updatedAt: serverTimestamp()
    });
    
    console.log('‚úÖ Location updated successfully');
  } catch (error: any) {
    console.error('üí• Error updating location:', error);
    throw error;
  }
};

/**
 * Delete a location
 * @param {string} locationId - ID of the location to delete
 * @returns {Promise<void>}
 */
export const deleteLocation = async (locationId: string): Promise<void> => {
  try {
    console.log('üóëÔ∏è [Database Service] Starting location deletion for:', locationId);
    
    // First delete all associated conditions
    console.log('üóëÔ∏è Deleting associated conditions...');
    const deletedConditionsCount = await deleteAllLocationConditions(locationId);
    console.log(`‚úÖ Deleted ${deletedConditionsCount} associated conditions`);

    // Then delete the location document
    const locationRef = doc(db, "locations", locationId);
    
    // Delete the document
    await deleteDoc(locationRef)
      .then(() => {
        console.log("Location successfully deleted!");
      })
      .catch((error) => {
        console.error("Error deleting location: ", error);
        throw error;
      });
    
    console.log('‚úÖ Location and all associated conditions deleted successfully');
  } catch (error: any) {
    console.error('üí• Error deleting location:', error);
    throw error;
  }
};

/**
 * Delete all locations for a specific hunt (useful when deleting a hunt)
 * @param {string} huntId - ID of the hunt
 * @returns {Promise<number>} - Number of locations deleted
 */
export const deleteAllHuntLocations = async (huntId: string): Promise<number> => {
  try {
    console.log('üóëÔ∏è [Database Service] Deleting all locations for hunt:', huntId);
    
    const q = query(
      collection(db, 'locations'),
      where('huntId', '==', huntId)
    );

    const querySnapshot = await getDocs(q);
    const deletePromises: Promise<void>[] = [];

    querySnapshot.forEach((docSnapshot) => {
      deletePromises.push(deleteDoc(doc(db, 'locations', docSnapshot.id)));
    });

    await Promise.all(deletePromises);
    
    console.log(`‚úÖ Deleted ${querySnapshot.size} locations for hunt ${huntId}`);
    return querySnapshot.size;
  } catch (error: any) {
    console.error('üí• Error deleting hunt locations:', error);
    throw error;
  }
};

// ========================================
// CONDITIONS COLLECTION FUNCTIONS
// ========================================

/**
 * Create a new condition for a location
 * @param {Omit<Condition, 'conditionId'>} conditionData - Condition data without ID
 * @returns {Promise<string>} - ID of the created condition
 */
export const createCondition = async (conditionData: Omit<Condition, 'conditionId'>): Promise<string> => {
  try {
    console.log('üîí [Database Service] Creating new condition for location:', conditionData.locationId);
    
    const docRef = await addDoc(collection(db, 'conditions'), {
      locationId: conditionData.locationId,
      type: conditionData.type,
      requiredLocationId: conditionData.requiredLocationId,
      startTime: conditionData.startTime,
      endTime: conditionData.endTime,
      createdAt: serverTimestamp()
    });
    
    console.log('‚úÖ Condition created successfully with ID:', docRef.id);
    return docRef.id;
  } catch (error: any) {
    console.error('üí• Error creating condition:', error);
    throw error;
  }
};

/**
 * Get all conditions for a specific location
 * @param {string} locationId - ID of the location
 * @returns {Promise<Condition[]>} - Array of conditions for the location
 */
export const getLocationConditions = async (locationId: string): Promise<Condition[]> => {
  try {
    console.log('üîç [Database Service] Getting conditions for location:', locationId);
    
    const q = query(
      collection(db, 'conditions'),
      where('locationId', '==', locationId)
    );

    const querySnapshot = await getDocs(q);
    const conditions: Condition[] = [];

    querySnapshot.forEach((doc) => {
      const conditionData = doc.data();
      conditions.push({
        conditionId: doc.id,
        locationId: conditionData.locationId,
        type: conditionData.type,
        requiredLocationId: conditionData.requiredLocationId,
        startTime: conditionData.startTime,
        endTime: conditionData.endTime
      });
    });

    console.log(`‚úÖ [Database Service] Found ${conditions.length} conditions for location`);
    return conditions;
  } catch (error: any) {
    console.error('üí• [Database Service] Error getting location conditions:', error);
    throw error;
  }
};

/**
 * Get a specific condition by ID
 * @param {string} conditionId - ID of the condition
 * @returns {Promise<Condition | null>} - Condition object or null if not found
 */
export const getConditionById = async (conditionId: string): Promise<Condition | null> => {
  try {
    const docRef = doc(db, 'conditions', conditionId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      const conditionData = docSnap.data();
      return {
        conditionId: docSnap.id,
        locationId: conditionData.locationId,
        type: conditionData.type,
        requiredLocationId: conditionData.requiredLocationId,
        startTime: conditionData.startTime,
        endTime: conditionData.endTime
      } as Condition;
    } else {
      return null;
    }
  } catch (error) {
    console.error('Error getting condition:', error);
    throw error;
  }
};

/**
 * Update a condition's information
 * @param {string} conditionId - ID of the condition to update
 * @param {Partial<Omit<Condition, 'conditionId' | 'locationId'>>} updates - Fields to update
 * @returns {Promise<void>}
 */
export const updateCondition = async (
  conditionId: string, 
  updates: Partial<Omit<Condition, 'conditionId' | 'locationId'>>
): Promise<void> => {
  try {
    const docRef = doc(db, 'conditions', conditionId);
    await updateDoc(docRef, {
      ...updates,
      updatedAt: serverTimestamp()
    });
    
    console.log('‚úÖ Condition updated successfully');
  } catch (error: any) {
    console.error('üí• Error updating condition:', error);
    throw error;
  }
};

/**
 * Delete a condition
 * @param {string} conditionId - ID of the condition to delete
 * @returns {Promise<void>}
 */
export const deleteCondition = async (conditionId: string): Promise<void> => {
  try {
    console.log('üóëÔ∏è [Database Service] Starting condition deletion for:', conditionId);
    
    const conditionRef = doc(db, "conditions", conditionId);
    
    await deleteDoc(conditionRef)
      .then(() => {
        console.log("Condition successfully deleted!");
      })
      .catch((error) => {
        console.error("Error deleting condition: ", error);
        throw error;
      });
    
    console.log('‚úÖ Condition deleted successfully');
  } catch (error: any) {
    console.error('üí• Error deleting condition:', error);
    throw error;
  }
};

/**
 * Delete all conditions for a specific location (useful when deleting a location)
 * @param {string} locationId - ID of the location
 * @returns {Promise<number>} - Number of conditions deleted
 */
export const deleteAllLocationConditions = async (locationId: string): Promise<number> => {
  try {
    console.log('üóëÔ∏è [Database Service] Deleting all conditions for location:', locationId);
    
    const q = query(
      collection(db, 'conditions'),
      where('locationId', '==', locationId)
    );

    const querySnapshot = await getDocs(q);
    const deletePromises: Promise<void>[] = [];

    querySnapshot.forEach((docSnapshot) => {
      deletePromises.push(deleteDoc(doc(db, 'conditions', docSnapshot.id)));
    });

    await Promise.all(deletePromises);
    
    console.log(`‚úÖ Deleted ${querySnapshot.size} conditions for location ${locationId}`);
    return querySnapshot.size;
  } catch (error: any) {
    console.error('üí• Error deleting location conditions:', error);
    throw error;
  }
};

/**
 * Delete a hunt
 * @param {string} huntId - ID of the hunt to delete
 * @param {string} userId - ID of the user (for validation)
 * @returns {Promise<void>}
 */
export const deleteHunt = async (huntId: string, userId: string): Promise<void> => {
  try {
    console.log('üóëÔ∏è [Database Service] Starting hunt deletion for:', huntId);
    
    // First verify the hunt belongs to the user
    const hunt = await getHuntById(huntId);
    if (!hunt) {
      throw new Error('Hunt not found');
    }
    
    if (hunt.userId !== userId) {
      throw new Error('Unauthorized: Hunt does not belong to this user');
    }

    // First delete all associated locations
    console.log('üóëÔ∏è Deleting associated locations...');
    const deletedLocationsCount = await deleteAllHuntLocations(huntId);
    console.log(`‚úÖ Deleted ${deletedLocationsCount} associated locations`);

    // Then delete the hunt document
    const huntRef = doc(db, "hunts", huntId);
    
    // Delete the hunt document
    await deleteDoc(huntRef)
      .then(() => {
        console.log("Hunt successfully deleted!");
      })
      .catch((error) => {
        console.error("Error deleting hunt: ", error);
        throw error;
      });
    
    console.log('‚úÖ Hunt and all associated locations deleted successfully');
  } catch (error: any) {
    console.error('üí• Error deleting hunt:', error);
    throw error;
  }
};